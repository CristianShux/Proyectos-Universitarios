# Portafolio de Proyectos

Este repositorio contiene los trabajos pr谩cticos realizados durante mi formaci贸n acad茅mica. A continuaci贸n, se describen los proyectos desarrollados en diferentes asignaturas.

## TP Introducci贸n a la Programaci贸n

**Descripci贸n:**
El proyecto de Introducci贸n a la Programaci贸n abarca los conceptos b谩sicos de programaci贸n, estructuras de control, tipos de datos, funciones e interfaz.
El trabajo consiste en un juego cuyo objetivo es adivinar una palabra. No se arriesgan letras sino palabras completas. Se sabe de antemano la longitud de la palabra y el juego debe avisar cuales letras de las palabras son incorrectas (no estan en la palabra), cuales son parcialmente correctas (estan en la palabra pero en otra ubicaci贸n) y cuales correctas (estan en la palabra exactamente en esa ubicaci贸n). Se acaba cuando el jugador se queda sin intentos o sin tiempo.


**Tecnolog铆as Utilizadas:**
- Lenguaje de Programaci贸n: Python

**Objetivos:**
- Comprender los fundamentos de la programaci贸n.
- Desarrollar habilidades para resolver problemas b谩sicos de programaci贸n.

**Caracter铆sticas Principales:**
- Implementaci贸n de algoritmos b谩sicos.
- Uso de estructuras de control como bucles y condicionales.
- Creaci贸n de funciones simples.

**Repositorio:**
[TP Introducci贸n a la Programaci贸n](https://github.com/CristianShux/Proyectos-Universitarios/tree/main/TP%20INTRODUCCION%20A%20LA%20PROGRAMACION)

## TP Organizaci贸n del Computador

**Descripci贸n:**
El proyecto de Organizaci贸n del Computador se desarrolla y pone en pr谩ctica los conceptos de arquitectura ARM.
El trabajo consiste en un juego en donde el capit谩n de la nave (jugador) controla la nave que avanza libremente por el espacio, una matriz de 20 filas x 50 columnas. Van 
apareciendo filas de asteroides, la nave debe evitar chocar con los asteroides, son diez anillos y los asteroides pueden tener diferente tama帽o, cada anillo es una fila de asteroides. El juego termina cuando llega al planeta o choca con un asteroide. Al llegar a la fila 19 se considera que lleg贸 al planeta


**Tecnolog铆as Utilizadas:**
- Lenguaje de Programaci贸n: Ensamblador

**Objetivos:**
- Entender la arquitectura b谩sica de un computador.
- Aprender a programar en lenguaje ensamblador.
- Conocer el funcionamiento interno de los componentes del computador.
- Comprender la manipulaci贸n de datos utilizando registros, pila y memoria.

**Caracter铆sticas Principales:**
- Datos almacenados en registros, pila y memoria
- Modos de direccionamiento 
- Llamada a procedimientos del usuario e interrupciones del sistema
- Codificaci贸n de caracteres ASCII
- Conversi贸n entre bases Decimal -> Binario, Binario -> Decimal

**Repositorio:**
[TP Organizaci贸n del Computador](https://github.com/CristianShux/Proyectos-Universitarios/tree/main/TP%20ORGANIZACION%20DEL%20COMPUTADOR)

## TP Programaci贸n I

**Descripci贸n:**
El proyecto de Programaci贸n I introduce conceptos de programaci贸n orientada a objetos (POO), estructuras de datos, funciones, bucles y algoritmos basicos.
El objetivo de este trabajo es desarrollar un video juego en el cual la Astro-MegaShip(nave de combate) elimine la mayor cantidad de Destructores Estelares, sin ser destruida en el intento. La nave, la bala, el asteroide y el enemigo son los objetos principales de este juego implementados en un entorno entregado por la universidad.

**Tecnolog铆as Utilizadas:**
- Lenguaje de Programaci贸n: Java

**Objetivos:**
- Aprender los principios de la programaci贸n orientada a objetos.
- Implementar estructuras de datos b谩sicas y su manipulaci贸n.
- Desarrollar habilidades para dise帽ar y programar videojuegos.
- Mejorar la capacidad para resolver problemas utilizando funciones y algoritmos eficientes.
- Entender y aplicar conceptos de manejo de eventos y animaci贸n en un entorno gr谩fico.

**Caracter铆sticas Principales:**
- Creaci贸n de clases y objetos para la nave, enemigos, asteroides y balas.
- Implementaci贸n de l贸gica de colisiones entre objetos.
- Manejo de eventos del teclado para controlar la nave y disparar proyectiles.
- Desarrollo de contadores y estad铆sticas del juego, como puntaje y vida.
- Gesti贸n de diferentes rondas y niveles de dificultad a medida que avanza el juego.
- Uso de archivos multimedia para sonidos y gr谩ficos.
- Reinicio del juego en caso de ganar o perder.

**Repositorio:**
[TP Programaci贸n I](https://github.com/CristianShux/Proyectos-Universitarios/tree/main/TP%20PROGRAMACION%20I)

## TP Programaci贸n II

**Descripci贸n:**
El proyecto de Programaci贸n II profundiza y abarca todos los conceptos de POO, estructuras de datos un poco mas avanzadas, algoritmos m谩s complejos y la implementacion de un problema real. No solo se vio practica en codigo sino que tambien antes de la implementacion especificacion de tads necesarios, diagrama de clases y interfaz de la solucion.
El trabajo consiste en Amazing, la gigante empresa de comercio electr贸nico, que necesita mejorar su sistema de entrega de paquetes. Nos piden dise帽ar un sistema que simule el proceso de entrega de paquetes a sus clientes y poder calcular el costo total que debe pagar el cliente.

**Tecnolog铆as Utilizadas:**
- Lenguaje de Programaci贸n: Java

**Objetivos:**
- Perfeccionar las habilidades en programaci贸n orientada a objetos.
- Implementar estructuras de datos avanzadas.
- Especificacion y abstraccion de lo pedido antes de la implementacion.
- Realizar un buen dise帽o de aplicacion, si esta bien dise帽ado estara bien programado.
- Identificacion del invariante de representacion.

**Caracter铆sticas Principales:**
- Diagrama de clases utilizando UML
- Dise帽o utilizando conceptos de programacion orientada a objetos que incluyen herencia y polimorfismo.
- Dise帽o utilizando otros conceptos como sobreescritura, sobrecarga, interfaces, clases y metodos abstractos.
- Manejo de excepciones.
- Prueba unitaria J-UNIT

**Repositorio:**
[TP Programaci贸n II](https://github.com/CristianShux/Proyectos-Universitarios/tree/main/TP%20PROGRAMACION%20II)

## TP Sistemas Operativos y Redes

**Descripci贸n:**
El proyecto de Sistemas Operativos y Redes se enfoca en el dise帽o y despliegue de una red empresarial para la compa帽铆a Manucho, que se dedica a la fabricaci贸n de productos industriales de alta tecnolog铆a. La empresa busca establecer una nueva sede en Ciudad XYZ para el "Proyecto Zeta". Este proyecto incluye el dise帽o de una red bien estructurada y eficiente, que conecte la sede principal con las sucursales en Ciudad A y Ciudad B. Adem谩s, se abordar谩n los conceptos de sistemas operativos, como la gesti贸n de procesos y memoria.

**Tecnolog铆as Utilizadas:**
- Cisco Packet Tracer

**Objetivos:**
- Dise帽ar una red privada utilizando la direcci贸n IP 192.168.0.0 y aplicar subredes seg煤n las necesidades de la compa帽铆a.
- Segmentar la red por departamento para facilitar la administraci贸n y minimizar la propagaci贸n de tr谩fico innecesario.
- Conectar todos los routers de las sucursales utilizando direcciones IP p煤blicas apropiadas para la cantidad de nodos.
- Implementar el protocolo de enrutamiento RIP versi贸n 2 en toda la red para garantizar la conectividad entre todos los nodos.
- Entender el funcionamiento de los sistemas operativos.
- Aprender sobre la gesti贸n de procesos y memoria.
- Conocer los fundamentos de las redes de computadoras.

**Caracter铆sticas Principales:**
- Implementaci贸n de una red empresarial que conecta la sede principal en Ciudad XYZ con las sucursales en Ciudad A y Ciudad B.
- Segmentaci贸n de la red por departamentos utilizando subredes.
- Uso de switches y routers Cisco para la interconexi贸n de las redes locales con la sede principal.
- Aplicaci贸n del protocolo de enrutamiento RIP versi贸n 2.
- Implementaci贸n de programas de gesti贸n de procesos y manejo de memoria en sistemas operativos.
- Dise帽o de sistemas de archivos y desarrollo de aplicaciones de red b谩sicas.

**Repositorio:**
[TP Sistemas Operativos y Redes](https://github.com/CristianShux/Proyectos-Universitarios/tree/main/TP%20SISTEMAS%20OPERATIVOS%20Y%20REDES)

## TP1 Programaci贸n III

**Descripci贸n:**
El primer trabajo pr谩ctico de Programaci贸n III se centra en el desarrollo de aplicaciones utilizando patrones de dise帽o y t茅cnicas de programaci贸n. Al ser el primero y la primera interaccion con lo que es WindowBuilder para las interfaces visuales en Java, es un trabajo de reconocimiento del mismo y familizarizacion, claramente se utilizan conceptos ya adquiridos en programacion I-II.
Este trabajo consiste en implentar una aplicacion para jugar al famoso juego "2048".La aplicacion cuenta con una interfaz visual y con los elementos adecuados para realizar
las acciones del juego. Ademas del funcionamiento normal del 2048, se lleva la cuenta del puntaje acumulado por el usuario y se registran los mejores puntajes para luego dar una interfaz para consultar tablas de posiciones historicas.


**Tecnolog铆as Utilizadas:**
- Lenguaje de Programaci贸n: Java
- WindowBuilder

**Objetivos:**
- Aplicar patrones de dise帽o en el desarrollo de software.
- Desarrollar aplicaciones robustas y escalables.
- Aplicar una arquitectura de software multicapa dividida en niveles de presentaci贸n, negocio y datos.
- Cumplir estrictamente el principio de separated presentation: el c贸digo de negocio no debe conocer la existencia de la interfaz, y la interfaz debe solicitar servicios al c贸digo de negocio.

**Caracter铆sticas Principales:**
- Uso de arquitectura multicapa y forms and controls.
- Desarrollo de interfaces gr谩ficas de usuario.
- Creacion de un juego 2048 totalmente funcional y mejorado.
- Leer y sobreescribir un archivo.
- Utilizacion de excepciones y manejo de las mismas.

**Repositorio:**
[TP1 Programaci贸n III](https://github.com/CristianShux/Proyectos-Universitarios/tree/main/TP1%20PROGRAMACION%20III)

## TP2 Programaci贸n III

**Descripci贸n:**
El segundo trabajo pr谩ctico de Programaci贸n III se enfoca en la implementaci贸n de una aplicaci贸n utilizando conceptos de grafos, algoritmos de optimizaci贸n, algoritmos de recorrido en grafos, y esta implementado el algoritmo de Prim para crear un arbol generador minimo.
El objetivo del trabajo es implementar una aplicaci贸n para resolver el problema de dise帽o de regiones de un pa铆s, similar al planteado por R. Assun莽茫o et al. Tenemos un grafo 
G que representa las provincias del pa铆s, con un v茅rtice por provincia y una arista por cada par de provincias lim铆trofes. Cada arista tiene un peso que representa la similitud entre las dos provincias (el c谩lculo de este valor no es parte del trabajo, sino que es un dato proporcionado por el usuario).

**Tecnolog铆as Utilizadas:**
- Lenguaje de Programaci贸n: Java
- WindowBuilder
- Gson
- JMapViewer

**Objetivos:**
- Resolver problemas de optimizaci贸n en la divisi贸n de un pa铆s en regiones utilizando algoritmos de grafos.
- Desarrollar una interfaz gr谩fica para cargar, visualizar y analizar el grafo de provincias del pa铆s.
- Implementar un algoritmo que construya un 谩rbol generador m铆nimo.
- Implementar un algoritmo que elimine las k-1 aristas mas pesadas de un grafo.
- Utilizar y manejar una estructura de datos avanzada como los grafos.

**Caracter铆sticas Principales:**
- Desarrollo de algoritmos de recorrido y b煤squeda en grafos.
- Manejo de excepciones y archivos.
- Implementaci贸n de grafos para representar las provincias del pa铆s y sus relaciones lim铆trofes.
- Desarrollo de un algoritmo para construir un 谩rbol generador m铆nimo del grafo.
- Desarrollo de un algoritmo para eliminar las aristas mas pesadas del grafo.
- Interfaz gr谩fica para cargar y visualizar el grafo de provincias, as铆 como las regiones resultantes despu茅s de aplicar el algoritmo.
- Interaccion con el usuario para cargar pesos de las aristas del grafo.
- Leer un archivo externo con informacion en este caso un JSON con los datos de entrada.
- El grafo es un tipo generico para mayor flexibilidad y generalizacion.
- Pruebas unitarias con JUNIT para las clases mas importantes del proyecto.

## TP3 Programaci贸n III

**Descripci贸n:**
El tercer trabajo pr谩ctico de Programaci贸n III se enfoca en poder entender las heuristicas implementando algoritmos golosos, nos familiarizamos con el hecho de que ante un problema NP-Completo una de las posibilidades cuando no podemos dar una solucion exacta a un problema, es implementar algoritmos aproximados como las heuristicas, que la calidad de la solucion es mala pero tenemos buena complejidad.
El objetivo del trabajo es la implementaci贸n de un algoritmo goloso para resolver el problema de clique de peso m谩ximo en un grafo, el cual es NP-Completo. La aplicaci贸n puede leer distintos grafos desde archivos JSON, encuentra una clique con el mayor peso posible utilizando un algoritmo goloso, el cual tiene en cuenta diferentes criterios a eleccion para llevarlo a cabo puede comparar por valor, peso, cantidad de vecinos y por ultimo visualiza los resultados en una interfaz de usuario.

**Tecnolog铆as Utilizadas:**
- Lenguaje de Programaci贸n: Java
- WindowBuilder
- Gson

**Objetivos:**
- Implementar un algoritmo goloso para hallar una clique de peso m谩ximo en un grafo.
- Desarrollar una aplicaci贸n que lea y procese datos de un grafo desde un archivo.
- Visualizar el grafo y la clique obtenida en una interfaz de usuario.
- Proporcionar estad铆sticas de la ejecuci贸n del algoritmo.
  
**Caracter铆sticas Principales:**
- Tener la posibilidad de aplicar diferentes comparadores al algoritmo goloso.
- Implementacion del algoritmo FruchtermanReingold con algunas modificaciones, que toma el grafo, el ancho, el alto de la pantalla y devuelve las posiciones en las que se tienen que graficar los vertices del grafo para que no se superpongan y se grafiquen bien en el area dada.
- Pruebas unitarias con JUNIT para las clases mas importantes del proyecto.
- Leer varios archivos externos con informacion en este caso un JSON con los datos de entrada de los diferentes grafos.
- El grafo es un tipo generico para mayor flexibilidad y generalizacion.
- 
**Repositorio:**
[TP3 Programaci贸n III](https://github.com/CristianShux/Proyectos-Universitarios/tree/main/TP3%20PROGRAMACION%20III)

---

**Gracias por ver** 
